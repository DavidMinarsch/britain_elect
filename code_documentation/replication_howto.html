<h1 id="introduction">Introduction</h1>
<p>This document describes code used to generate estimates of opinion at the constituency level. It is distributed as part of a zip archive that contains some of the files needed to generate these estimates. The document is built with Knitr, an example of literate programming, such that the R source code used to generate these estimates is embedded within the document itself. This R code can be found at <code>replication_howto.R</code>.</p>
<h1 id="if-life-gives-you-a-chainsaw">If life gives you a chainsaw…</h1>
<p>We’ve written this document so that other researchers can estimate opinion at the constituency level without investing substantial effort in sourcing, reconciling and recoding census and survey data. We’ve used this code (or versions of it) to estimate constituency-level opinion on Europe, on immigration, on taxation, on crime, and on other issues.</p>
<p>If you want to understand this code, you should read the accompanying <a href="http://constituencyopinion.org.uk/wp-content/uploads/2014/10/constituency-estimates-technical-report.pdf">technical report</a>. The technical report describes what we’re doing: the code below describes how we do it.</p>
<p>The technical report gives details on how individual level predictors and post-stratification can be combined with spatial data and constituency-level predictors to produce estimates of opinions. For the “political” opinions we’ve studied so far, demographic predictors make sense, and explain a reasonable proportion of the individual level variance in the relevant opinion.</p>
<p>However, there are some circumstances where we would caution against using this code to estimate opinion at the constituency level.</p>
<p>First, don’t use this code if the opinion you’re interested in is not obviously related to individual respondents’ occupation or education. It would be wrong, for example, to estimate constituency level opinion concerning <a href="https://yougov.co.uk/news/2012/05/08/britains-favourite-shakespeare/">favourite Shakespeare plays</a>, for example.</p>
<p>Second, don’t use this code if the opinion you’re interested in is, by its very nature, local. When we estimate responses towards Europe (as we do in this document), there is a common stimulus to which people are reacting. Our modelling exploits commonalities in responses amongst people who live in different places but who are alike in their characteristics. If, however, we were to estimate opinion concerning satisfaction with local councils, there would be no such commonality.</p>
<h1 id="dependencies">Dependencies</h1>
<p>Estimating constituency level opinion is a complex endeavour, which depends upon several pieces of freely available software. We begin by setting out the software dependencies you need, before moving on to discuss the data dependencies.</p>
<h2 id="software-dependencies">Software dependencies</h2>
<p>First, you’ll need a recent version of <a href="http://www.r-project.org/">R</a>. This document was created using the following R version:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">R.Version</span>()$version.string</code></pre>
<p>[1] “R version 3.1.1 (2014-07-10)”</p>
<p>and the following random seed:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">2511</span>)</code></pre>
<p>Second, you’ll need a version of <a href="http://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-winbugs/">WinBUGS</a>. You need WinBUGS rather than an other Gibbs sampler (like, say, <a href="http://mcmc-jags.sourceforge.net/">JAGS</a>) because, to the best of our knowledge, only WinBUGS can draw from a conditional autoregressive normal distribution. If you’re not running a Windows computer, you should know that WinBUGS can be run through WINE on Linux, and through Parallels on Macs.</p>
<p>Third, you’ll need a number of R libraries. This document requires the following libraries:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(foreign)
<span class="kw">library</span>(memisc)
<span class="kw">library</span>(car)
<span class="kw">library</span>(maptools)
<span class="kw">library</span>(spdep)
<span class="kw">library</span>(R2WinBUGS)
<span class="kw">library</span>(arm)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(plyr)
<span class="kw">library</span>(rgeos)</code></pre>
<p>Not all of these libraries are strictly necessary to generate constituency-level estimates. Some – like <code>car</code> – are used only for helping in recoding variables.</p>
<h2 id="data-dependencies">Data dependencies</h2>
<p>Moving on to the data dependencies, you’ll first need a data-set with responses from several thousand individuals. This data-set must contain information on (a) an opinion of interest, (b) the constituency of each respondent; and (c) additional individual-level variables which can be matched with the information collected by the Census. In this document, we use Wave 2 of the British Election Study 2015. We cannot redistribute this data, so you will need to download it and change the <code>bespath</code> variable to read the data into R. Additionally, we’re going to drop three-quarters of the observations to reduce the computational burden.</p>
<pre class="sourceCode r"><code class="sourceCode r">bespath &lt;-<span class="st"> &quot;~/Dropbox/constituency-estimates-data/bes-2015/BES2015_W2_Panel_v2.0.sav&quot;</span>
besdat &lt;-<span class="st"> </span><span class="kw">read.spss</span>(bespath, 
    <span class="dt">to.data.frame=</span><span class="ot">TRUE</span>)
<span class="kw">nrow</span>(besdat)
besdat &lt;-<span class="st"> </span>besdat[<span class="kw">sample</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(besdat),<span class="kw">nrow</span>(besdat)/<span class="dv">4</span>),]
<span class="kw">nrow</span>(besdat)</code></pre>
<p>Second, you’ll need some constituency-level variables and the necessary look-up codes to link these variables to the BES data. These are contained in the zipped folder.</p>
<pre class="sourceCode r"><code class="sourceCode r">auxpath &lt;-<span class="st"> &quot;./canonical_seatvars_2011census.csv&quot;</span>
lookuppath &lt;-<span class="st"> &quot;./name2pa.csv&quot;</span>
aux &lt;-<span class="st"> </span><span class="kw">read.csv</span>(auxpath)
lookup &lt;-<span class="st"> </span><span class="kw">read.csv</span>(lookuppath)</code></pre>
<p>Third, you’ll need some post-stratification weights. The weights we currently use are transitional weights. We use the sample of anonymised records (SAR) from the 2001 census, and rake this to the marginal distributions from the 2011 census. Once the SAR from the 2011 census is available, we can use information from the 2011 census exclusively.</p>
<pre class="sourceCode r"><code class="sourceCode r">pswpath &lt;-<span class="st"> &quot;canonical_weights_2001SARS_2011margins_flatfile.csv&quot;</span>
psw &lt;-<span class="st"> </span><span class="kw">read.csv</span>(pswpath)</code></pre>
<p>Fourth, you’ll need some shapefiles giving details of the boundaries of the parliamentary constituencies used in Great Britain. Once again, we cannot redistribute this data, as it is held by the Ordnance Survey. Additionally, the Boundary Line data file is quite large. You will need to download this data file yourself, and change the variable <code>geopath</code> in order to read this into R.</p>
<pre class="sourceCode r"><code class="sourceCode r">geopath &lt;-<span class="st"> &quot;~/Dropbox/constituency-estimates-data/westminster_const_region.shp&quot;</span>
geo &lt;-<span class="st"> </span><span class="kw">readShapePoly</span>(geopath)</code></pre>
<p>You will also need some manual additions – instances of constituencies which are either genuine islands, or which appear such because of faults in the shapefile.</p>
<pre class="sourceCode r"><code class="sourceCode r">joinpath &lt;-<span class="st"> &quot;./joins_to_add.csv&quot;</span>
joins.to.add &lt;-<span class="st"> </span><span class="kw">read.csv</span>(joinpath, <span class="dt">header =</span> <span class="ot">TRUE</span>)</code></pre>
<h1 id="recoding">Recoding</h1>
<p>Unfortunately, a lot of work goes into recoding variables in order to make sure that the different sources of data play together nicely. We start with the BES data, before moving on to the geodata.</p>
<h2 id="bes-re-codes">BES re-codes</h2>
<h3 id="dependent-variable">Dependent variable</h3>
<p>We start with our dependent variable – the opinion of interest. Here, we’re going to examine how respondents would vote in a hypothetical referendum on EU membership. This is stored in the BES as a variable called <code>euRefVoteW2</code>. The possible values of this variable are as follows:</p>
<ul>
<li>1 (Leave the EU)</li>
<li>0 (Stay in the EU)</li>
<li>2 (I would not vote)</li>
<li>9999 (Don’t know)</li>
</ul>
<p>We will recode these values into a new variable called <code>y</code> (a more descriptive variable name would normally be preferable, but by calling the variable y we make this code more reusable). This variable will have value 1 if the respondent would vote to leave the EU.</p>
<pre class="sourceCode r"><code class="sourceCode r">besdat$y &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.numeric</span>(besdat$euRefVoteW2) ==<span class="st"> </span><span class="dv">2</span>)
besdat$y[<span class="kw">as.numeric</span>(besdat$euRefVoteW2) &gt;<span class="st"> </span><span class="dv">2</span>] &lt;-<span class="st"> </span><span class="ot">NA</span></code></pre>
<h3 id="individual-level-variables">Individual-level variables</h3>
<p>We now embark on a lengthy series of recodes designed to match the BES data with the Census weights. This involves recoding variables for age, gender, marital status, housing tenure, highest level of education, and private sector occupation. If any of these recoding operations are unclear, we recommend consulting the BES codebook.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Gender</span>
besdat$gender &lt;-<span class="st"> </span><span class="kw">factor</span>(besdat$gender,<span class="dt">exclude=</span><span class="kw">c</span>(<span class="st">&quot;Skipped&quot;</span>,<span class="st">&quot;Not Asked&quot;</span>))

<span class="co"># Age</span>
besdat$ageGroup &lt;-<span class="st"> </span><span class="dv">8</span> -<span class="st"> </span>((besdat$Age &lt;=<span class="st"> </span><span class="dv">19</span>) +<span class="st"> </span>
<span class="st">    </span>(besdat$Age &lt;=<span class="st"> </span><span class="dv">24</span>) +<span class="st"> </span>
<span class="st">    </span>(besdat$Age &lt;=<span class="st"> </span><span class="dv">29</span>) +<span class="st"> </span>
<span class="st">    </span>(besdat$Age &lt;=<span class="st"> </span><span class="dv">44</span>) +<span class="st"> </span>
<span class="st">    </span>(besdat$Age &lt;=<span class="st"> </span><span class="dv">59</span>) +<span class="st"> </span>
<span class="st">    </span>(besdat$Age &lt;=<span class="st"> </span><span class="dv">64</span>) +<span class="st"> </span>
<span class="st">    </span>(besdat$Age &lt;=<span class="st"> </span><span class="dv">74</span>))
besdat$ageGroup &lt;-<span class="st"> </span><span class="kw">factor</span>(besdat$ageGroup,
    <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;16-19&quot;</span>, <span class="st">&quot;20-24&quot;</span>,<span class="st">&quot;25-29&quot;</span>,<span class="st">&quot;30-44&quot;</span>,<span class="st">&quot;45-59&quot;</span>,<span class="st">&quot;60-64&quot;</span>,<span class="st">&quot;65-74&quot;</span>,<span class="st">&quot;75+&quot;</span>))
besdat$ageGroup &lt;-<span class="st"> </span><span class="kw">replace</span>(besdat$ageGroup,
    <span class="kw">is.na</span>(besdat$ageGroup),
    <span class="st">&quot;45-59&quot;</span>) <span class="co"># assign NAs to most frequent category</span>

<span class="co"># Marital status</span>
besdat$maritalStatus &lt;-<span class="st"> </span>car:::<span class="kw">recode</span>(besdat$marital,
    <span class="st">&quot;c(&#39;Married&#39;)=&#39;Married or re-married&#39;;</span>
<span class="st">    c(&#39;Skipped&#39;,&#39;Not Asked&#39;)=NA;</span>
<span class="st">    else=&#39;Single (never married), separated, divorced or widowed&#39;&quot;</span>)

## Housing tenure
besdat$housing &lt;-<span class="st"> </span>car:::<span class="kw">recode</span>(besdat$housing,
    <span class="st">&quot;c(&#39;Own the leasehold/freehold outright&#39;,</span>
<span class="st">        &#39;Buying leasehold/freehold on a mortgage&#39;)=&#39;Owns&#39;;</span>
<span class="st">    c(&#39;Rented from local authority&#39;,</span>
<span class="st">        &#39;Rented from private landlord&#39;,</span>
<span class="st">        &#39;It belongs to a Housing Association&#39;)=&#39;Rents&#39;;</span>
<span class="st">    else = &#39;Rents&#39;&quot;</span>)

## Education
besdat$qualifications &lt;-<span class="st"> </span>car:::<span class="kw">recode</span>(besdat$education,
    <span class="st">&quot;&#39;No formal qualifications&#39;=&#39;No qualifications&#39;;</span>
<span class="st">    &#39;Youth training certificate/skillseekers&#39;=&#39;Level 2&#39;;</span>
<span class="st">    &#39;Recognised trade apprenticeship completed&#39;=&#39;Level 2&#39;;</span>
<span class="st">    &#39;Clerical and commercial&#39;=&#39;Level 1&#39;;</span>
<span class="st">    &#39;City and Guild certificate&#39;=&#39;Level 1&#39;;</span>
<span class="st">    &#39;City and Guild certificate - advanced&#39;=&#39;Level 2&#39;;</span>
<span class="st">    &#39;onc&#39;=&#39;Level 2&#39;;</span>
<span class="st">    &#39;CSE grades 2-5&#39;=&#39;Level 1&#39;;</span>
<span class="st">    &#39;CSE grade 1, GCE O level, GCSE, School Certificate&#39;=&#39;Level 2&#39;;</span>
<span class="st">    &#39;Scottish Ordinary/ Lower Certificate&#39;=&#39;Level 2&#39;;</span>
<span class="st">    &#39;GCE A level or Higher Certificate&#39;=&#39;Level 3&#39;;</span>
<span class="st">    &#39;Scottish Higher Certificate&#39;=&#39;Level 3&#39;;</span>
<span class="st">    &#39;Nursing qualification (eg SEN, SRN, SCM, RGN)&#39;=&#39;Level 4/5&#39;;</span>
<span class="st">    &#39;Teaching qualification (not degree)&#39;=&#39;Level 4/5&#39;;</span>
<span class="st">    &#39;University diploma&#39;=&#39;Level 4/5&#39;;</span>
<span class="st">    &#39;University or CNAA first degree (eg BA, B.Sc, B.Ed)&#39;=&#39;Level 4/5&#39;;</span>
<span class="st">    &#39;University or CNAA higher degree (eg M.Sc, Ph.D)&#39;=&#39;Level 4/5&#39;;</span>
<span class="st">    &#39;Other technical, professional or higher qualification&#39;=&#39;Other&#39;;else = NA&quot;</span>)

## Private sector occupation
besdat$privateSector &lt;-<span class="st"> </span>car:::<span class="kw">recode</span>(besdat$work_type,
    <span class="st">&quot;c(1,2)=&#39;Private&#39;;c(8,9)=NA;else=&#39;Public&#39;&quot;</span>)</code></pre>
<p>Having recoded these variables, we now drop all rows in the data without a response to the question on EU exit.</p>
<pre class="sourceCode r"><code class="sourceCode r">besdat &lt;-<span class="st"> </span><span class="kw">subset</span>(besdat,!<span class="kw">is.na</span>(besdat$y))</code></pre>
<p>We also drop all rows in the data with missing values for any of our individual level variables. Normally, such a complete-cases strategy would be ill-advisable, but since these individual-level variables are fairly common, the rates of missingness are low, and we can concentrate on complete cases without too much loss of data.</p>
<pre class="sourceCode r"><code class="sourceCode r">tokeepvars &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;gender&quot;</span>,<span class="st">&quot;ageGroup&quot;</span>,<span class="st">&quot;maritalStatus&quot;</span>,
    <span class="st">&quot;housing&quot;</span>,<span class="st">&quot;qualifications&quot;</span>,<span class="st">&quot;privateSector&quot;</span>)
tokeep &lt;-<span class="st"> </span><span class="kw">complete.cases</span>(besdat[,tokeepvars])
besdat &lt;-<span class="st"> </span>besdat[tokeep,]
<span class="kw">rm</span>(tokeep, tokeepvars)</code></pre>
<p>Finally, we make sure that the reference codes for the constituency match across data-sets. Because we will eventually need to refer to the constituencies in WinBUGS, we create a continuously numbered version of the constituency reference code. This differs from the Press Association reference codes, which include Northern Irish constituencies which we omit.</p>
<pre class="sourceCode r"><code class="sourceCode r">besdat$refno &lt;-<span class="st"> </span>besdat$pconrefno
besdat &lt;-<span class="st"> </span><span class="kw">merge</span>(besdat,lookup,
    <span class="dt">by=</span><span class="st">&quot;refno&quot;</span>,
    <span class="dt">all.x=</span>T,<span class="dt">all.y=</span>F)
besdat &lt;-<span class="st"> </span><span class="kw">subset</span>(besdat, !<span class="kw">is.na</span>(besdat$refno))

<span class="co"># Get constituency identifier</span>
<span class="co"># PA numbers are non-consecutive</span>
<span class="co"># So make sure we take number of levels from the factor</span>
besdat$constindex &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">factor</span>(besdat$refno))
constindex &lt;-<span class="st"> </span>besdat$constindex

## Create look-up table
const.lookup &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">refno=</span><span class="kw">unique</span>(besdat$refno),
  <span class="dt">refno.num =</span> <span class="kw">unique</span>(constindex))</code></pre>
<h2 id="geo-data-recodes">Geo-data recodes</h2>
<p>We begin by ensuring a match between the codes by which the individual polygons in the shapefile are referred to, and the codes we are using. Because it is possible that the shapefile includes more mainland constituencies than are found in the data (for example, if one constituency was unfortunate enough never to be included in the sample), we must add these on to our lookup list.</p>
<pre class="sourceCode r"><code class="sourceCode r">geo$refno &lt;-<span class="st"> </span>lookup$refno[<span class="kw">match</span>(<span class="kw">as.character</span>(geo$NAME),lookup$ShapeFileName)]

### Index this in the same way as the continuous numbering
geo$refno.num &lt;-<span class="st"> </span><span class="ot">NA</span>
geo$refno.num &lt;-<span class="st"> </span>const.lookup$refno.num[<span class="kw">match</span>(geo$refno,const.lookup$refno)]

<span class="co"># Find additional constituencies not present in the lookup table</span>
extras &lt;-<span class="st"> </span>geo$refno[<span class="kw">is.na</span>(geo$refno.num)]
extras.num &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from=</span>(<span class="kw">max</span>(geo$refno.num,<span class="dt">na.rm=</span>T)+<span class="dv">1</span>),
  <span class="dt">by=</span><span class="dv">1</span>,
  <span class="dt">length.out=</span><span class="kw">length</span>(extras))
extras &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">refno=</span>extras,<span class="dt">refno.num=</span>extras.num)
<span class="kw">rm</span>(extras.num)

## Add to lookup table
const.lookup &lt;-<span class="st"> </span><span class="kw">rbind</span>(const.lookup,extras)

## And now repeat the match,
## Overwriting refno in the process
geo$refno &lt;-<span class="st"> </span>const.lookup$refno.num[<span class="kw">match</span>(geo$refno,const.lookup$refno)]
geo$refno.num &lt;-<span class="st"> </span><span class="ot">NULL</span></code></pre>
<p>We now transform the data into a slightly different R object (a Spatial Polygons data frame), taking care to preserve the order of the polygons.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gpclibPermit</span>()
sp.const &lt;-<span class="st"> </span><span class="kw">unionSpatialPolygons</span>(geo, geo$refno)
<span class="co"># Lose detail</span>
sp.const &lt;-<span class="st"> </span><span class="kw">gSimplify</span>(sp.const,<span class="dv">100</span>)

dist.size &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">cbind</span>(geo$HECTARES, geo$refno))
<span class="kw">colnames</span>(dist.size) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;area&quot;</span>,<span class="st">&quot;refno&quot;</span>)
dist.size&lt;-dist.size[<span class="kw">order</span>(dist.size$refno),]
<span class="kw">rownames</span>(dist.size)&lt;-dist.size$refno

area.spdf &lt;-<span class="st"> </span><span class="kw">SpatialPolygonsDataFrame</span>(sp.const, dist.size)

## Reorder according to refno
area.spdf &lt;-<span class="st"> </span>area.spdf[ <span class="kw">order</span>(area.spdf$refno),]</code></pre>
<p>We now create the adjacency matrices. Here, we must add the joins we mentioned previously.</p>
<pre class="sourceCode r"><code class="sourceCode r">nb.districts &lt;-<span class="st"> </span><span class="kw">poly2nb</span>(area.spdf)

## Join islands to the mainland
for (i in <span class="dv">1</span>:<span class="kw">nrow</span>(joins.to.add)) {
    a &lt;-<span class="st"> </span><span class="kw">as.integer</span>(const.lookup$refno.num[<span class="kw">which</span>(const.lookup$refno==joins.to.add[i,<span class="dv">1</span>])])
    b &lt;-<span class="st"> </span><span class="kw">as.integer</span>(const.lookup$refno.num[<span class="kw">which</span>(const.lookup$refno==joins.to.add[i,<span class="dv">2</span>])])
    nb.districts[[a]] &lt;-<span class="st"> </span><span class="kw">c</span>(nb.districts[[a]],b)
    nb.districts[[a]] &lt;-nb.districts[[a]][nb.districts[[a]]!=<span class="dv">0</span>]
    nb.districts[[b]] &lt;-<span class="st"> </span><span class="kw">c</span>(nb.districts[[b]],a)
    nb.districts[[b]] &lt;-nb.districts[[b]][nb.districts[[b]]!=<span class="dv">0</span>]
}

nb &lt;-<span class="st"> </span><span class="kw">unlist</span>(nb.districts)
weight &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, <span class="dt">times=</span><span class="kw">length</span>(nb)) 
num &lt;-<span class="st"> </span><span class="kw">card</span>(nb.districts)

spdata &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;nb&quot;</span>, <span class="st">&quot;weight&quot;</span>, <span class="st">&quot;num&quot;</span>)</code></pre>
<h2 id="constituency-level-information">Constituency-level information</h2>
<p>We now recode information pertaining to the constituency level. In some instances, this involves mere renaming:</p>
<pre class="sourceCode r"><code class="sourceCode r">### Some renaming
for (i in <span class="kw">c</span>(<span class="st">&quot;private&quot;</span>,<span class="st">&quot;female&quot;</span>,<span class="st">&quot;married&quot;</span>,<span class="st">&quot;owns&quot;</span>,<span class="st">&quot;education&quot;</span>,<span class="st">&quot;socgrd&quot;</span>,<span class="st">&quot;age&quot;</span>)) {
    <span class="kw">names</span>(aux)[<span class="kw">names</span>(aux) ==<span class="st"> </span>i] &lt;-<span class="st"> </span><span class="kw">paste0</span>(i,<span class="st">&quot;SL&quot;</span>)
}

<span class="co"># transform lagged vote shares for 3 main parties</span>
aux$lab10[<span class="kw">is.na</span>(aux$lab10)] &lt;-<span class="st"> </span><span class="dv">1</span>
aux$con10[<span class="kw">is.na</span>(aux$con10)] &lt;-<span class="st"> </span><span class="dv">1</span>
aux$ld10[<span class="kw">is.na</span>(aux$ld10)] &lt;-<span class="st"> </span><span class="dv">1</span>
aux$lab10logit &lt;-<span class="st"> </span>car:::<span class="kw">logit</span>(aux$lab10,<span class="dt">percents =</span> <span class="ot">TRUE</span>)
aux$con10logit &lt;-<span class="st"> </span>car:::<span class="kw">logit</span>(aux$con10,<span class="dt">percents =</span> <span class="ot">TRUE</span>)
aux$ld10logit &lt;-<span class="st"> </span>car:::<span class="kw">logit</span>(aux$ld10,<span class="dt">percents =</span> <span class="ot">TRUE</span>)</code></pre>
<p>In other cases, there is more heavy lifting to do. Here, we construct constituency-level aggregates for age and education from our census weights.</p>
<pre class="sourceCode r"><code class="sourceCode r">education &lt;-<span class="st"> </span><span class="kw">aggregate</span>(psw$weight,
    <span class="kw">list</span>(<span class="dt">refno=</span>psw$parliamentary.constituency<span class="fl">.2010</span>,<span class="dt">education=</span>psw$education),
    sum,<span class="dt">na.rm=</span>T)

education &lt;-<span class="st"> </span><span class="kw">ddply</span>(education,.(refno),function(df){
    <span class="kw">data.frame</span>(<span class="dt">educlevel4plus =</span> <span class="kw">sum</span>(df[df$education %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Level 4/5&quot;</span>),<span class="st">&quot;x&quot;</span>],<span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">educnoqual =</span> <span class="kw">sum</span>(df[df$education %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;No qualifications&quot;</span>),<span class="st">&quot;x&quot;</span>],<span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
})

aux &lt;-<span class="st"> </span><span class="kw">merge</span>(aux, education, <span class="dt">by =</span> <span class="st">&quot;refno&quot;</span>, <span class="dt">all.x=</span><span class="ot">TRUE</span>)

ageGroup &lt;-<span class="st"> </span><span class="kw">aggregate</span>(psw$weight,
    <span class="kw">list</span>(<span class="dt">refno=</span>psw$parliamentary.constituency<span class="fl">.2010</span>,<span class="dt">ageGroup=</span>psw$age0),
    sum,<span class="dt">na.rm=</span>T)
ageGroup &lt;-<span class="st"> </span><span class="kw">ddply</span>(ageGroup,.(refno),function(df){
    <span class="kw">data.frame</span>(<span class="dt">age16to24 =</span> <span class="kw">sum</span>(df[df$ageGroup %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;16-19&quot;</span>,<span class="st">&quot;20-24&quot;</span>),<span class="st">&quot;x&quot;</span>],<span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
               <span class="dt">age65plus =</span> <span class="kw">sum</span>(df[df$ageGroup %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;65-74&quot;</span>,<span class="st">&quot;75+&quot;</span>),<span class="st">&quot;x&quot;</span>],<span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
})

aux &lt;-<span class="st"> </span><span class="kw">merge</span>(aux, ageGroup, <span class="dt">by =</span> <span class="st">&quot;refno&quot;</span>, <span class="dt">all.x=</span><span class="ot">TRUE</span>)

<span class="kw">rm</span>(education,ageGroup)</code></pre>
<p>For housekeeping purposes, we’ll merge this auxiliary information with the BES data-frame, making sure only to include the relevant constituencies. Note how we scale the variables so that they are approximately normally distributed. Scaling variables is often a necessary step in MCMC sampling so as to improve sampling speed and avoid over/under-run errors.</p>
<pre class="sourceCode r"><code class="sourceCode r">aux &lt;-<span class="st"> </span><span class="kw">subset</span>(aux,aux$refno %in%<span class="st"> </span><span class="kw">unique</span>(const.lookup$refno))
aux &lt;-<span class="st"> </span><span class="kw">merge</span>(aux,const.lookup,<span class="dt">all.x=</span>T,<span class="dt">all.y=</span>F)
## Order aux seat correctly for later use
aux &lt;-<span class="st"> </span>aux[<span class="kw">order</span>(aux$refno.num),]
## Scale variables
vars.to.scale &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;con10&quot;</span>,<span class="st">&quot;lab10&quot;</span>,<span class="st">&quot;ld10&quot;</span>,
    <span class="st">&quot;log.earn&quot;</span>,<span class="st">&quot;nonwhite&quot;</span>,<span class="st">&quot;relig.christian&quot;</span>,
    <span class="st">&quot;relig.refused&quot;</span>,<span class="st">&quot;relig.none&quot;</span>,<span class="st">&quot;relig.other&quot;</span>,
    <span class="st">&quot;ageSL&quot;</span>,<span class="st">&quot;privateSL&quot;</span>,<span class="st">&quot;ownsSL&quot;</span>,<span class="st">&quot;femaleSL&quot;</span>,
    <span class="st">&quot;marriedSL&quot;</span>,<span class="st">&quot;educationSL&quot;</span>,<span class="st">&quot;socgrdSL&quot;</span>,
    <span class="st">&quot;log.density&quot;</span>,<span class="st">&quot;lab10logit&quot;</span>,<span class="st">&quot;con10logit&quot;</span>,<span class="st">&quot;ld10logit&quot;</span>,
    <span class="st">&quot;educlevel4plus&quot;</span>,<span class="st">&quot;educnoqual&quot;</span>,
    <span class="st">&quot;age16to24&quot;</span>,<span class="st">&quot;age65plus&quot;</span>)

for (v in vars.to.scale) {
    aux[,v] &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">scale</span>(aux[,v]))
}
besdat &lt;-<span class="st"> </span><span class="kw">merge</span>(besdat, aux, 
    <span class="dt">by.x =</span> <span class="st">&quot;refno&quot;</span>, <span class="dt">by.y =</span> <span class="st">&quot;refno&quot;</span>,
    <span class="dt">all.x =</span> T,
    <span class="dt">suffixes =</span> <span class="kw">c</span>(<span class="st">&quot;.x&quot;</span>,<span class="st">&quot;&quot;</span>))

constindex &lt;-<span class="st"> </span>besdat$constindex
besdat$region.num &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(besdat$gor)</code></pre>
<h1 id="the-model">The model</h1>
<p>Having recoded much of our data, we can now turn to the WinBUGS model. This model loops over the individual observations, pulling into the constituency-level effects, which are modelled respectively as a function of constituency-level covariates and a series of spatially correlated random effects. Here, we describe the model as an R language function, which is then written out to a file.</p>
<pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> </span>function() {
    for (i in <span class="dv">1</span>:nObs) {
        y[i] ~<span class="st"> </span><span class="kw">dbern</span>(p[i])

        <span class="kw">logit</span>(p[i]) &lt;-<span class="st"> </span>alpha +<span class="st"> </span>
<span class="st">            </span>gamma[i] +<span class="st"> </span>
<span class="st">            </span>beta[constindex[i]] +<span class="st"> </span>
<span class="st">            </span>v[constindex[i]]

        gamma[i] &lt;-<span class="st"> </span>gamma.female*female[i] +<span class="st"> </span>gamma.rent*rent[i] +<span class="st"> </span>
<span class="st">                    </span>gamma.notMarried*notMarried[i] +
<span class="st">                    </span>gamma.private*private[i] +<span class="st"> </span>
<span class="st">                    </span>gamma.ageGroup[ageGroup[i]] +<span class="st"> </span>
<span class="st">                    </span>gamma.qualifications[qualifications[i]]
    }

    gamma.female ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, .<span class="dv">0001</span>)
    gamma.rent ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, .<span class="dv">0001</span>)
    gamma.notMarried ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, .<span class="dv">0001</span>)
    gamma.private ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, .<span class="dv">0001</span>)

    for(k in <span class="dv">1</span>:nAgeGroups){
       gamma.ageGroup[k] ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, tau.ageGroup)
      }
    for(k in <span class="dv">1</span>:nQualifications){
       gamma.qualifications[k] ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, tau.qualifications)
      }
      

    tau.ageGroup  &lt;-<span class="st"> </span><span class="kw">pow</span>(sigma.ageGroup, -<span class="dv">2</span>)
    sigma.ageGroup ~<span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>, <span class="dv">2</span>)
    tau.qualifications  &lt;-<span class="st"> </span><span class="kw">pow</span>(sigma.qualifications, -<span class="dv">2</span>)
    sigma.qualifications ~<span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>, <span class="dv">2</span>)

    for (j in <span class="dv">1</span>:nConst) {
        beta[j] &lt;-<span class="st"> </span>beta.density *<span class="st"> </span>density[j]  +<span class="st"> </span>
<span class="st">                    </span>beta.nonwhite *<span class="st"> </span>nonwhite[j]  +
<span class="st">                    </span>beta.earnings *<span class="st"> </span>earnings[j] +<span class="st"> </span>
<span class="st">                    </span>beta.religchristian *<span class="st"> </span>relig.christian[j] +
<span class="st">                    </span>beta.religother *<span class="st"> </span>relig.other[j] +
<span class="st">                    </span>beta.religrefuse *<span class="st"> </span>relig.refuse[j] +
<span class="st">                    </span>beta.femaleSL *<span class="st"> </span>femaleSL[j] +
<span class="st">                    </span>beta.marriedSL *<span class="st"> </span>marriedSL[j] +
<span class="st">                    </span>beta.privateSL *<span class="st"> </span>privateSL[j] +
<span class="st">                    </span>beta.ownsSL *<span class="st"> </span>ownsSL[j] +
<span class="st">                    </span>beta.socgrdSL *<span class="st"> </span>socgrdSL[j] +
<span class="st">                    </span>beta.age16to24 *<span class="st"> </span>age16to24[j] +<span class="st"> </span>beta.age65plus *<span class="st"> </span>age65plus[j] +<span class="st">                     </span>
<span class="st">                    </span>beta.educnoqual *<span class="st"> </span>educnoqual[j] +<span class="st"> </span>
<span class="st">                    </span>beta.educlevel4plus *<span class="st"> </span>educlevel4plus[j] +
<span class="st">                    </span>beta.con10 *<span class="st"> </span>con10[j] +<span class="st"> </span>
<span class="st">                    </span>beta.lab10 *<span class="st"> </span>lab10[j] +<span class="st"> </span>
<span class="st">                    </span>beta.ld10 *<span class="st"> </span>ld10[j] +
<span class="st">                    </span>beta.region[region[j]] +<span class="st"> </span>
<span class="st">                    </span>u[j]
        u[j] ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, tauu)
    }

    for(k in <span class="dv">1</span>:nRegion){
        beta.region[k] ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, tau.region)
    }

    v[<span class="dv">1</span>:nConst] ~<span class="st"> </span><span class="kw">car.normal</span>(nb[], weight[], num[], tauv)
    alpha ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.density ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.nonwhite ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.earnings ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.religchristian ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.religother ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.religrefuse ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.femaleSL ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.marriedSL ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.privateSL  ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.ownsSL  ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.socgrdSL ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.age16to24 ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.age65plus ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.educnoqual ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.educlevel4plus ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.con10 ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.lab10 ~<span class="st"> </span><span class="kw">dflat</span>()
    beta.ld10 ~<span class="st"> </span><span class="kw">dflat</span>()

    tau.region &lt;-<span class="st"> </span><span class="kw">pow</span>(sigma.region,-<span class="dv">2</span>)
    sigma.region ~<span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">2</span>)

    tauu &lt;-<span class="st"> </span><span class="kw">pow</span>(sigmasquv*sigmamix, -<span class="dv">1</span>)
    tauv &lt;-<span class="st"> </span><span class="kw">pow</span>(sigmasquv*(<span class="dv">1</span>-sigmamix), -<span class="dv">1</span>)
    sigmasquv &lt;-<span class="st"> </span><span class="kw">pow</span>(sigmauv,<span class="dv">2</span>)
    sigmauv ~<span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>, <span class="dv">2</span>)
    sigmamix ~<span class="st">  </span><span class="kw">dbeta</span>(<span class="dv">1</span>,<span class="dv">1</span>)
}

<span class="kw">write.model</span>(model, <span class="st">&quot;model.bug&quot;</span>)</code></pre>
<p>Unfortunately, passing data to WinBUGS can be quite tedious. The following chunk of code sets up the various variables, which are then passed by name in the string at the end of the code chunk.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Prepare data for WinBugs</span>
y &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(besdat$y)
nObs &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">length</span>(y))
nConst &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.vector</span>(<span class="kw">max</span>(const.lookup$refno.num)))
constindex &lt;-<span class="st"> </span><span class="kw">as.vector</span>(constindex)

female &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.numeric</span>(besdat$gender ==<span class="st"> &quot;Female&quot;</span>))
notMarried &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(besdat$maritalStatus ==<span class="st"> &quot;Single (never married), separated, divorced or widowed&quot;</span>)
rent &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(besdat$housing ==<span class="st"> &quot;Rents&quot;</span>)
private &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(besdat$privateSector ==<span class="st"> &quot;Private&quot;</span>)

nAgeGroups &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(besdat$ageGroup))
ageGroup &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(besdat$ageGroup)
nsocialGrades &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(besdat$socialGrade))
socialGrade &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(besdat$socialGrade)
nQualifications &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(besdat$qualifications))
qualifications &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(besdat$qualifications)

## Constituency level stuff
density &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$log.density)
earnings &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$log.earn)
nonwhite &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$nonwhite)
region &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(aux$region)
nRegion &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(region))
relig.christian &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$relig.christian)
relig.other &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$relig.other)
relig.refuse &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$relig.refused)
femaleSL &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$femaleSL)
marriedSL &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$marriedSL)
privateSL &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$privateSL)
ownsSL &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$ownsSL)
socgrdSL &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$socgrdSL)

age16to24 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$age16to24)
age65plus &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$age65plus)
educnoqual &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$educnoqual)
educlevel4plus &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$educlevel4plus)

lab10logit &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$lab10logit)
con10logit &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$con10logit)
ld10logit &lt;-<span class="st"> </span><span class="kw">as.vector</span>(aux$ld10logit)
lab10 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">as.numeric</span>(aux$lab10logit))
con10 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">as.numeric</span>(aux$con10logit))
ld10 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">as.numeric</span>(aux$ld10logit))


bugsdata &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;nObs&quot;</span>,<span class="st">&quot;female&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;rent&quot;</span>,<span class="st">&quot;notMarried&quot;</span>,<span class="st">&quot;private&quot;</span>,
            <span class="st">&quot;ageGroup&quot;</span>,<span class="st">&quot;nAgeGroups&quot;</span>
            ,<span class="st">&quot;nQualifications&quot;</span>,<span class="st">&quot;qualifications&quot;</span>
            ,<span class="st">&quot;nConst&quot;</span>
            ,<span class="st">&quot;density&quot;</span>
            ,<span class="st">&quot;nonwhite&quot;</span>,<span class="st">&quot;earnings&quot;</span>
            ,<span class="st">&quot;constindex&quot;</span>
            ,<span class="st">&quot;relig.christian&quot;</span>,<span class="st">&quot;relig.other&quot;</span>,<span class="st">&quot;relig.refuse&quot;</span>
            ,<span class="st">&quot;femaleSL&quot;</span>, <span class="st">&quot;marriedSL&quot;</span>, <span class="st">&quot;privateSL&quot;</span>
            ,<span class="st">&quot;ownsSL&quot;</span>, <span class="st">&quot;socgrdSL&quot;</span>
            ,<span class="st">&quot;age16to24&quot;</span>, <span class="st">&quot;age65plus&quot;</span>
            ,<span class="st">&quot;educnoqual&quot;</span>,<span class="st">&quot;educlevel4plus&quot;</span>
            ,<span class="st">&quot;region&quot;</span>,<span class="st">&quot;nRegion&quot;</span>
            ,<span class="st">&quot;con10&quot;</span>,<span class="st">&quot;lab10&quot;</span>,<span class="st">&quot;ld10&quot;</span>
        )</code></pre>
<p>WinBUGS will occasionally throw a hissy fit if its own best guess at initial values causes improbable results. For this reason, it’s best to pass WinBUGS an initialization function. Again, this can be unwieldy, hence the tongue-in-cheek name of the function, <code>tiny.inits</code>. We’ll also use this opportunity to set a random seed to ensure reproducibility.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">2511</span>)
tiny.inits &lt;-<span class="st"> </span>function() {
            alpha &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.density &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.religrefuse &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.religother &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.religchristian &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.nonwhite &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.earnings &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.femaleSL  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.marriedSL  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.privateSL   &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.ownsSL   &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.socgrdSL  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.age16to24  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.age65plus  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            beta.educnoqual  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)            
            beta.educlevel4plus  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)            
            beta.con10  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)            
            beta.lab10  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)            
            beta.ld10  &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)            

            gamma.female &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            gamma.rent &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            gamma.notMarried &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            gamma.private &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>)
            gamma.ageGroup &lt;-<span class="st"> </span><span class="kw">rnorm</span>(nAgeGroups,<span class="dv">0</span>,<span class="dv">1</span>)
            gamma.qualifications &lt;-<span class="st"> </span><span class="kw">rnorm</span>(nQualifications,<span class="dv">0</span>,<span class="dv">1</span>)
            u =<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,nConst)
            v =<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,nConst)

            <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">alpha=</span>alpha,<span class="dt">beta.density=</span>beta.density,
                        <span class="dt">beta.religrefuse=</span>beta.religrefuse,
                        <span class="dt">beta.religother=</span>beta.religother,
                        <span class="dt">beta.religchristian=</span>beta.religchristian,
                        <span class="dt">beta.nonwhite=</span>beta.nonwhite,<span class="dt">beta.earnings=</span>beta.earnings,
                        <span class="dt">beta.femaleSL=</span>beta.femaleSL, <span class="dt">beta.marriedSL=</span>beta.marriedSL,
                        <span class="dt">beta.privateSL=</span>beta.privateSL, <span class="dt">beta.ownsSL=</span>beta.ownsSL,
                        <span class="dt">beta.socgrdSL=</span>beta.socgrdSL,
                        <span class="dt">beta.age16to24=</span>beta.age16to24,
                        <span class="dt">beta.age65plus=</span>beta.age65plus,
                        <span class="dt">beta.educnoqual=</span>beta.educnoqual,
                        <span class="dt">beta.educlevel4plus=</span>beta.educlevel4plus,
                        <span class="dt">beta.con10=</span>beta.con10,
                        <span class="dt">beta.lab10=</span>beta.lab10,
                        <span class="dt">beta.ld10=</span>beta.ld10,
                        <span class="dt">gamma.female=</span>gamma.female,
                        <span class="dt">gamma.rent=</span>gamma.rent,
                        <span class="dt">gamma.notMarried=</span> gamma.notMarried,
                        <span class="dt">gamma.private=</span>gamma.private,
                        <span class="dt">gamma.ageGroup=</span>gamma.ageGroup
                        ,<span class="dt">gamma.qualifications=</span>gamma.qualifications
                        ,<span class="dt">u=</span>u,<span class="dt">v=</span>v))
        }</code></pre>
<h1 id="estimation">Estimation</h1>
<p>We’ve now re-coded all our data, made it play nicely together, and specified our model. There are two steps left – estimation of the model, and post-stratification. Estimation can be quite computationally intensive – and post-stratification quite memory intensive. For these reasons, we’re going to set the number of MCMC samples to a small number.</p>
<pre class="sourceCode r"><code class="sourceCode r">### You could use these
my.iter &lt;-<span class="st"> </span><span class="dv">50000</span>
my.burnin &lt;-<span class="st"> </span><span class="dv">10000</span>
my.thin &lt;-<span class="st"> </span><span class="dv">100</span>

### But we&#39;ll use these
my.iter &lt;-<span class="st"> </span><span class="dv">200</span>
my.burnin &lt;-<span class="st"> </span><span class="dv">100</span>
my.thin &lt;-<span class="st"> </span><span class="dv">1</span></code></pre>
<p>Here comes the estimation! You will need to change the Bugs directory to match its location on your system.</p>
<pre class="sourceCode r"><code class="sourceCode r">my.bugs.dir &lt;-<span class="st"> &quot;/home/chris/.wine/drive_c/Program Files (x86)/WinBUGS14&quot;</span>

model.sim &lt;-<span class="st"> </span><span class="kw">bugs</span>(<span class="dt">data=</span><span class="kw">c</span>(bugsdata, spdata), 
        <span class="dt">inits =</span> tiny.inits,
     <span class="dt">model.file=</span><span class="st">&quot;model.bug&quot;</span>,
      <span class="dt">parameters.to.save=</span><span class="kw">c</span>(<span class="st">&quot;alpha&quot;</span>,
        <span class="st">&quot;gamma.female&quot;</span>,
        <span class="st">&quot;gamma.rent&quot;</span>,
        <span class="st">&quot;gamma.notMarried&quot;</span>,
        <span class="st">&quot;gamma.private&quot;</span>,
        <span class="st">&quot;gamma.ageGroup&quot;</span>
        ,<span class="st">&quot;gamma.qualifications&quot;</span>
        ,<span class="st">&quot;beta&quot;</span>,<span class="st">&quot;v&quot;</span>
        ,<span class="st">&quot;sigmauv&quot;</span>, <span class="st">&quot;sigmamix&quot;</span>, <span class="st">&quot;sigma.region&quot;</span>
        ,<span class="st">&quot;beta.density&quot;</span>
        ,<span class="st">&quot;beta.nonwhite&quot;</span>,<span class="st">&quot;beta.earnings&quot;</span>
        ,<span class="st">&quot;beta.religrefuse&quot;</span>,<span class="st">&quot;beta.religother&quot;</span>, <span class="st">&quot;beta.religchristian&quot;</span>
        ,<span class="st">&quot;beta.region&quot;</span>
        ,<span class="st">&quot;beta.femaleSL&quot;</span>,<span class="st">&quot;beta.marriedSL&quot;</span>,<span class="st">&quot;beta.privateSL&quot;</span>,<span class="st">&quot;beta.ownsSL&quot;</span>,<span class="st">&quot;beta.socgrdSL&quot;</span>
        ,<span class="st">&quot;beta.age16to24&quot;</span>,<span class="st">&quot;beta.age65plus&quot;</span>,<span class="st">&quot;beta.educnoqual&quot;</span>,<span class="st">&quot;beta.educlevel4plus&quot;</span>
        ,<span class="st">&quot;beta.con10&quot;</span>,<span class="st">&quot;beta.lab10&quot;</span>,<span class="st">&quot;beta.ld10&quot;</span>
        ), 
      <span class="dt">n.chains=</span><span class="dv">3</span>,
      <span class="dt">n.iter=</span>my.iter, 
      <span class="dt">n.burnin=</span>my.burnin, 
      <span class="dt">n.thin=</span>my.thin, 
      <span class="dt">debug=</span><span class="ot">FALSE</span>,
      <span class="dt">bugs.directory=</span>my.bugs.dir) </code></pre>
<p>We probably want to check whether these Markov Chains have converged:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(model.sim$summary[,<span class="st">&quot;Rhat&quot;</span>])</code></pre>
<p>Min. 1st Qu. Median Mean 3rd Qu. Max. 0.997 1.030 1.070 1.140 1.120 9.430</p>
<h1 id="post-stratification">Post-stratification</h1>
<p>Assuming that convergence has been achieved, we now need to post-stratify the results. This will involve loading in the post-stratification weights, and doing some book-keeping on the outcome of the WinBUGS model.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">load</span>(<span class="st">&quot;./canonical_weights_2001SARS_2011margins_Robj.RData&quot;</span>)

PSW &lt;-<span class="st"> </span><span class="kw">as.data.frame.table</span>(psw, <span class="dt">rownames =</span> <span class="ot">NULL</span>, <span class="dt">responseName =</span> <span class="st">&quot;N&quot;</span>)
<span class="kw">names</span>(PSW) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;refno&quot;</span>, <span class="st">&quot;gender&quot;</span>, <span class="st">&quot;ageGroup&quot;</span>, <span class="st">&quot;qualifications&quot;</span>,
                <span class="st">&quot;maritalStatus&quot;</span>, <span class="st">&quot;housing&quot;</span>, <span class="st">&quot;socgrd&quot;</span>, <span class="st">&quot;privateSector&quot;</span>, <span class="st">&quot;N&quot;</span>)

### Social grade not used here
PSW$socgrd &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="co"># assign re-formatted PSW as census data</span>
census &lt;-<span class="st"> </span>PSW
<span class="kw">rm</span>(PSW, psw)

## create census model matrix
census.mat &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(~<span class="st"> </span><span class="dv">1</span> +<span class="st"> </span><span class="kw">I</span>(gender==<span class="st">&quot;Female&quot;</span>) +<span class="st"> </span><span class="kw">I</span>(housing==<span class="st">&quot;Rents&quot;</span>) +<span class="st"> </span>
<span class="st">    </span><span class="kw">I</span>(maritalStatus==<span class="st">&quot;Single (never married), separated, divorced or widowed&quot;</span>) +<span class="st"> </span>
<span class="st">    </span><span class="kw">I</span>(privateSector==<span class="st">&quot;Private&quot;</span>) +
<span class="st">        </span>ageGroup +<span class="st"> </span>qualifications,
        <span class="dt">contrasts.arg =</span> <span class="kw">list</span>(<span class="dt">ageGroup =</span> <span class="kw">contrasts</span>(census$ageGroup, <span class="dt">contrasts=</span>F),
            <span class="dt">qualifications =</span> <span class="kw">contrasts</span>(census$qualifications, <span class="dt">contrasts=</span>F)
    ),
    <span class="dt">data =</span> census)

## Constituency effects
constituency.component &lt;-<span class="st"> </span>model.sim$mean$beta +<span class="st"> </span>model.sim$mean$v
constituency.component &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">constout =</span> constituency.component, 
    <span class="dt">refno.num =</span> <span class="dv">1</span>:nConst)
constituency.component &lt;-<span class="st"> </span><span class="kw">merge</span>(constituency.component,const.lookup)
constituency.component$refno.num &lt;-<span class="st"> </span><span class="ot">NULL</span>

## Rearrange coefs
the.coefs &lt;-<span class="st"> </span><span class="kw">c</span>(model.sim$mean$alpha,
        model.sim$mean$gamma.female,
        model.sim$mean$gamma.rent, 
        model.sim$mean$gamma.notMarried, 
        model.sim$mean$gamma.private,
        model.sim$mean$gamma.ageGroup
        ,model.sim$mean$gamma.qualifications
        )

    
### Get product

census$out &lt;-<span class="st">  </span><span class="kw">rowSums</span>(census.mat %*%<span class="st"> </span>the.coefs)

### Add the constituency effects
census &lt;-<span class="st"> </span><span class="kw">merge</span>(census,constituency.component,
        <span class="dt">by =</span> <span class="st">&quot;refno&quot;</span>,
        <span class="dt">all=</span>T)
census$cell.pred &lt;-<span class="st"> </span><span class="kw">inv.logit</span>(census$out +<span class="st"> </span>census$constout)

## Aggregate to constituency yhat
meanpreds &lt;-<span class="st"> </span>census$cell.pred *<span class="st"> </span>census$N
meanpreds &lt;-<span class="st"> </span><span class="kw">aggregate</span>(meanpreds,<span class="kw">list</span>(<span class="dt">refno=</span>census$refno),sum,<span class="dt">na.rm=</span>T)
<span class="kw">names</span>(meanpreds)[<span class="dv">2</span>] &lt;-<span class="st"> &quot;yhat&quot;</span>

meanpreds$yhat &lt;-<span class="st"> </span>meanpreds$yhat*<span class="dv">100</span>

meanpreds &lt;-<span class="st"> </span><span class="kw">merge</span>(meanpreds, lookup, <span class="dt">by =</span> <span class="st">&quot;refno&quot;</span>, 
    <span class="dt">all =</span> <span class="ot">TRUE</span>)</code></pre>
<p>We should now have our results in <code>meanpreds</code>, which can be saved, or merged with other data, or enter into another model, or…</p>
<pre class="sourceCode r"><code class="sourceCode r">meanpreds[<span class="dv">1</span>:<span class="dv">3</span>,<span class="kw">c</span>(<span class="st">&quot;refno&quot;</span>,<span class="st">&quot;YouGovName&quot;</span>,<span class="st">&quot;yhat&quot;</span>)]</code></pre>
<p>refno YouGovName yhat 1 1 Aberavon 52.90 2 10 Alyn and Deeside 61.65 3 100 Bristol North West 44.23</p>
